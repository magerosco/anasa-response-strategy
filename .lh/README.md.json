{
    "sourceFile": "README.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 73,
            "patches": [
                {
                    "date": 1725258548512,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1725258605369,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,7 +2,7 @@\n Package to isolate the logic that determines the return type of the controller based on the source (API/Web)\r\n \r\n This is an optional solution to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n \r\n-Note:\r\n+Note:**\r\n setMethod will set as API for all input\r\n If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n"
                },
                {
                    "date": 1725258613630,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,7 +2,7 @@\n Package to isolate the logic that determines the return type of the controller based on the source (API/Web)\r\n \r\n This is an optional solution to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n \r\n-Note:**\r\n+**Note:**\r\n setMethod will set as API for all input\r\n If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n"
                },
                {
                    "date": 1725258621065,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,6 +3,6 @@\n \r\n This is an optional solution to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n \r\n **Note:**\r\n-setMethod will set as API for all input\r\n-If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n+- setMethod will set as API for all input\r\n+- If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n"
                },
                {
                    "date": 1725258627288,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,4 +5,5 @@\n \r\n **Note:**\r\n - setMethod will set as API for all input\r\n - If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n+\r\n"
                },
                {
                    "date": 1725258810814,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,4 +6,5 @@\n **Note:**\r\n - setMethod will set as API for all input\r\n - If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n \r\n+How it works\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725258818278,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,5 +6,5 @@\n **Note:**\r\n - setMethod will set as API for all input\r\n - If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n \r\n-How it works\n\\ No newline at end of file\n+##How it works##\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725258824223,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,5 +6,5 @@\n **Note:**\r\n - setMethod will set as API for all input\r\n - If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n \r\n-##How it works##\n\\ No newline at end of file\n+## How it works\r\n"
                },
                {
                    "date": 1725258970436,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,4 +7,5 @@\n - setMethod will set as API for all input\r\n - If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n \r\n ## How it works\r\n+From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725258977020,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,5 +7,7 @@\n - setMethod will set as API for all input\r\n - If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n \r\n ## How it works\r\n-From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\n\\ No newline at end of file\n+From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\r\n+\r\n+```````\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725258982121,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,5 +9,7 @@\n \r\n ## How it works\r\n From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\r\n \r\n-```````\n\\ No newline at end of file\n+```\r\n+\r\n+```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725258991770,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,6 +10,75 @@\n ## How it works\r\n From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\r\n \r\n ```\r\n+<?php\r\n \r\n+namespace App\\Http\\Middleware;\r\n+\r\n+use Closure;\r\n+use Illuminate\\Http\\Request;\r\n+use SebastianBergmann\\Type\\Exception;\r\n+use Symfony\\Component\\HttpFoundation\\Response;\r\n+use Anasa\\ResponseStrategy\\ResponseStrategyFactory;\r\n+use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n+use Anasa\\ResponseStrategy\\Facades\\AdditionalDataRequest;\r\n+\r\n+class ApiOrWebMiddleware\r\n+{\r\n+    public function __construct(protected ResponseContextInterface $responseContext)\r\n+    {\r\n+    }\r\n+\r\n+    /**\r\n+     * Handle an incoming request.\r\n+     *\r\n+     * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response)  $next\r\n+     */\r\n+    public function handle(Request $request, Closure $next): Response\r\n+    {\r\n+        /**\r\n+         * Set additional data request:\r\n+         * this will add the controller, method, view and resource. It's\r\n+         * some dinamic data to be used in the strategy to identify and build\r\n+         * the response. A facade will be used.\r\n+         */\r\n+        $this->setAdditionalDataRequest($request);\r\n+\r\n+        $this->defineResponseStrategy();\r\n+\r\n+        return $next($request);\r\n+    }\r\n+\r\n+    private function setAdditionalDataRequest(Request $request): void\r\n+    {\r\n+        $action = $request->route()->getAction();\r\n+        $controller = class_basename($action['controller']);\r\n+        [, $methodName] = explode('@', $controller);\r\n+\r\n+        /**\r\n+         * facades, the intentions is to have a dinamic data abaliable for all app\r\n+         *  without need to create dependencies\r\n+         **/\r\n+\r\n+        AdditionalDataRequest::setMethod($request->expectsJson() || $request->is('api/*') ? 'API' : $methodName);\r\n+        AdditionalDataRequest::setView($request->route()->getName());\r\n+        AdditionalDataRequest::setRoute($request->route()->getName());\r\n+    }\r\n+\r\n+    /**\r\n+     * Used factory design patterns to create the response strategy.\r\n+     */\r\n+    public function defineResponseStrategy()\r\n+    {\r\n+        try {\r\n+            //Factory Method, returns a concrete instance based on the ResponseStrategy interface.\r\n+            $strategy = ResponseStrategyFactory::createStrategy(AdditionalDataRequest::getMethod());\r\n+        } catch (Exception $e) {\r\n+            throw new Exception('Unknown method');\r\n+        }\r\n+\r\n+        $this->responseContext->setStrategy($strategy);\r\n+    }\r\n+}\r\n+\r\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725259117779,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,9 @@\n \r\n ## How it works\r\n From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\r\n \r\n-```\r\n+```php\r\n <?php\r\n \r\n namespace App\\Http\\Middleware;\r\n \r\n"
                },
                {
                    "date": 1725259142341,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n - setMethod will set as API for all input\r\n - If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n \r\n ## How it works\r\n-From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\r\n+1- From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\r\n \r\n ```php\r\n <?php\r\n \r\n"
                },
                {
                    "date": 1725259148895,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,5 +80,5 @@\n         $this->responseContext->setStrategy($strategy);\r\n     }\r\n }\r\n \r\n-```\n\\ No newline at end of file\n+```\r\n"
                },
                {
                    "date": 1725259176399,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -81,4 +81,6 @@\n     }\r\n }\r\n \r\n ```\r\n+2- \r\n+\r\n"
                },
                {
                    "date": 1725259182438,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,4 +83,6 @@\n \r\n ```\r\n 2- \r\n \r\n+```php\r\n+```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725259211597,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -81,8 +81,41 @@\n     }\r\n }\r\n \r\n ```\r\n-2- \r\n+2- Set \r\n \r\n ```php\r\n+<?php\r\n+\r\n+namespace App\\Providers;\r\n+\r\n+use App\\Models\\User;\r\n+use App\\Observers\\UserObserver;\r\n+use App\\Repositories\\GatewayRepository;\r\n+use Illuminate\\Support\\ServiceProvider;\r\n+use App\\Repositories\\CrudRepositoryInterface;\r\n+use Anasa\\ResponseStrategy\\AdditionalDataRequest;\r\n+\r\n+class AppServiceProvider extends ServiceProvider\r\n+{\r\n+    /**\r\n+     * Register any application services.\r\n+     */\r\n+    public function register(): void\r\n+    {\r\n+        $this->app->bind(CrudRepositoryInterface::class, GatewayRepository::class);\r\n+        $this->app->singleton('additionalDataRequest', function ($app) {\r\n+            return new AdditionalDataRequest;\r\n+        });\r\n+    }\r\n+\r\n+    /**\r\n+     * Bootstrap any application services.\r\n+     */\r\n+    public function boot(): void\r\n+    {\r\n+        User::observe(UserObserver::class);\r\n+    }\r\n+}\r\n+\r\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725259216921,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -81,9 +81,9 @@\n     }\r\n }\r\n \r\n ```\r\n-2- Set \r\n+2- Set Service Provider and \r\n \r\n ```php\r\n <?php\r\n \r\n"
                },
                {
                    "date": 1725259222918,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -81,9 +81,9 @@\n     }\r\n }\r\n \r\n ```\r\n-2- Set Service Provider and \r\n+2- Set Service Provider and Response Se\r\n \r\n ```php\r\n <?php\r\n \r\n"
                },
                {
                    "date": 1725259228588,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -81,9 +81,9 @@\n     }\r\n }\r\n \r\n ```\r\n-2- Set Service Provider and Response Se\r\n+2- Set Service Provider and Response Service provider\r\n \r\n ```php\r\n <?php\r\n \r\n"
                },
                {
                    "date": 1725259242929,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -81,9 +81,9 @@\n     }\r\n }\r\n \r\n ```\r\n-2- Set Service Provider and Response Service provider\r\n+2- Set Service Provider and Response Service provider,\r\n \r\n ```php\r\n <?php\r\n \r\n@@ -113,9 +113,9 @@\n      * Bootstrap any application services.\r\n      */\r\n     public function boot(): void\r\n     {\r\n-        User::observe(UserObserver::class);\r\n+       //\r\n     }\r\n }\r\n \r\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725259252031,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,10 +88,8 @@\n <?php\r\n \r\n namespace App\\Providers;\r\n \r\n-use App\\Models\\User;\r\n-use App\\Observers\\UserObserver;\r\n use App\\Repositories\\GatewayRepository;\r\n use Illuminate\\Support\\ServiceProvider;\r\n use App\\Repositories\\CrudRepositoryInterface;\r\n use Anasa\\ResponseStrategy\\AdditionalDataRequest;\r\n"
                },
                {
                    "date": 1725259262309,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -100,9 +100,9 @@\n      * Register any application services.\r\n      */\r\n     public function register(): void\r\n     {\r\n-        $this->app->bind(CrudRepositoryInterface::class, GatewayRepository::class);\r\n+        //\r\n         $this->app->singleton('additionalDataRequest', function ($app) {\r\n             return new AdditionalDataRequest;\r\n         });\r\n     }\r\n"
                },
                {
                    "date": 1725259269020,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -100,9 +100,9 @@\n      * Register any application services.\r\n      */\r\n     public function register(): void\r\n     {\r\n-        //\r\n+        //...\r\n         $this->app->singleton('additionalDataRequest', function ($app) {\r\n             return new AdditionalDataRequest;\r\n         });\r\n     }\r\n"
                },
                {
                    "date": 1725259289151,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,11 +88,9 @@\n <?php\r\n \r\n namespace App\\Providers;\r\n \r\n-use App\\Repositories\\GatewayRepository;\r\n use Illuminate\\Support\\ServiceProvider;\r\n-use App\\Repositories\\CrudRepositoryInterface;\r\n use Anasa\\ResponseStrategy\\AdditionalDataRequest;\r\n \r\n class AppServiceProvider extends ServiceProvider\r\n {\r\n"
                },
                {
                    "date": 1725259313210,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -113,5 +113,6 @@\n        //\r\n     }\r\n }\r\n \r\n-```\n\\ No newline at end of file\n+```\r\n+\r\n"
                },
                {
                    "date": 1725259321119,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -115,4 +115,7 @@\n }\r\n \r\n ```\r\n \r\n+```php\r\n+\r\n+```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725259330305,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,6 +116,43 @@\n \r\n ```\r\n \r\n ```php\r\n+<?php\r\n \r\n+namespace App\\Providers;\r\n+\r\n+use Illuminate\\Support\\ServiceProvider;\r\n+use Anasa\\ResponseStrategy\\ResponseContext;\r\n+use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n+use Anasa\\ResponseStrategy\\Output\\ApiResponseStrategy;\r\n+use Anasa\\ResponseStrategy\\Output\\ViewResponseStrategy;\r\n+use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyData;\r\n+use Anasa\\ResponseStrategy\\Output\\RedirectResponseStrategy;\r\n+use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyDataInterface;\r\n+\r\n+class ResponseServiceProvider extends ServiceProvider\r\n+{\r\n+    public function register()\r\n+    {\r\n+        $this->app->bind(ApiResponseStrategy::class, function ($app) {\r\n+            return new ApiResponseStrategy();\r\n+        });\r\n+\r\n+        $this->app->bind(ViewResponseStrategy::class, function ($app) {\r\n+            return new ViewResponseStrategy();\r\n+        });\r\n+\r\n+        $this->app->bind(RedirectResponseStrategy::class, function ($app) {\r\n+            return new RedirectResponseStrategy();\r\n+        });\r\n+        $this->app->bind(StrategyDataInterface::class, function ($app) {\r\n+            return new StrategyData();\r\n+        });\r\n+\r\n+        $this->app->singleton(ResponseContextInterface::class, function ($app) {\r\n+            return new ResponseContext();\r\n+        });\r\n+    }\r\n+}\r\n+\r\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725259428107,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,12 +2,10 @@\n Package to isolate the logic that determines the return type of the controller based on the source (API/Web)\r\n \r\n This is an optional solution to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n \r\n-**Note:**\r\n-- setMethod will set as API for all input\r\n-- If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n \r\n+\r\n ## How it works\r\n 1- From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\r\n \r\n ```php\r\n"
                },
                {
                    "date": 1725259439096,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,10 +2,8 @@\n Package to isolate the logic that determines the return type of the controller based on the source (API/Web)\r\n \r\n This is an optional solution to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n \r\n-\r\n-\r\n ## How it works\r\n 1- From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\r\n \r\n ```php\r\n@@ -79,8 +77,9 @@\n     }\r\n }\r\n \r\n ```\r\n+\r\n 2- Set Service Provider and Response Service provider,\r\n \r\n ```php\r\n <?php\r\n"
                },
                {
                    "date": 1725259451088,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,8 +77,12 @@\n     }\r\n }\r\n \r\n ```\r\n+**Note:**\r\n+- setMethod will set as API for all input\r\n+- If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n+```\r\n \r\n 2- Set Service Provider and Response Service provider,\r\n \r\n ```php\r\n"
                },
                {
                    "date": 1725259457867,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,9 +80,9 @@\n ```\r\n **Note:**\r\n - setMethod will set as API for all input\r\n - If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n-```\r\n+```p\r\n \r\n 2- Set Service Provider and Response Service provider,\r\n \r\n ```php\r\n"
                },
                {
                    "date": 1725259464304,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,9 +80,11 @@\n ```\r\n **Note:**\r\n - setMethod will set as API for all input\r\n - If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n-```p\r\n+```php\r\n+AdditionalDataRequest::setMethod($request->expectsJson() || $request->is('api/*') ? 'API' : $methodName);\r\n+```\r\n \r\n 2- Set Service Provider and Response Service provider,\r\n \r\n ```php\r\n"
                },
                {
                    "date": 1725259482963,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,9 +77,9 @@\n     }\r\n }\r\n \r\n ```\r\n-**Note:**\r\n+**Notes:**\r\n - setMethod will set as API for all input\r\n - If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n ```php\r\n AdditionalDataRequest::setMethod($request->expectsJson() || $request->is('api/*') ? 'API' : $methodName);\r\n"
                },
                {
                    "date": 1725259568685,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n # anasa-response-strategy\r\n Package to isolate the logic that determines the return type of the controller based on the source (API/Web)\r\n \r\n-This is an optional solution to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n+This is an optional solution in laravel to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n \r\n ## How it works\r\n 1- From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\r\n \r\n"
                },
                {
                    "date": 1725259579913,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n # anasa-response-strategy\r\n Package to isolate the logic that determines the return type of the controller based on the source (API/Web)\r\n \r\n-This is an optional solution in laravel to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n+This is an optional solution in ##Laravel to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n \r\n ## How it works\r\n 1- From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\r\n \r\n"
                },
                {
                    "date": 1725259584988,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n # anasa-response-strategy\r\n Package to isolate the logic that determines the return type of the controller based on the source (API/Web)\r\n \r\n-This is an optional solution in ##Laravel to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n+This is an optional solution in ###Laravel## to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n \r\n ## How it works\r\n 1- From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\r\n \r\n"
                },
                {
                    "date": 1725259594353,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n # anasa-response-strategy\r\n Package to isolate the logic that determines the return type of the controller based on the source (API/Web)\r\n \r\n-This is an optional solution in ###Laravel## to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n+This is an optional solution in Laravel to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n \r\n ## How it works\r\n 1- From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\r\n \r\n"
                },
                {
                    "date": 1725259649197,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -157,5 +157,6 @@\n         });\r\n     }\r\n }\r\n \r\n-```\n\\ No newline at end of file\n+```\r\n+\r\n"
                },
                {
                    "date": 1725259659503,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -159,4 +159,5 @@\n }\r\n \r\n ```\r\n \r\n+3- Using \n\\ No newline at end of file\n"
                },
                {
                    "date": 1725259668056,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -159,5 +159,6 @@\n }\r\n \r\n ```\r\n \r\n-3- Using \n\\ No newline at end of file\n+3- Using it in your controller\r\n+\r\n"
                },
                {
                    "date": 1725259674527,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -161,4 +161,6 @@\n ```\r\n \r\n 3- Using it in your controller\r\n \r\n+```php\r\n+```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725259703040,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,196 @@\n+# anasa-response-strategy\r\n+Package to isolate the logic that determines the return type of the controller based on the source (API/Web)\r\n+\r\n+This is an optional solution in Laravel to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n+\r\n+## How it works\r\n+1- From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\r\n+\r\n+```php\r\n+<?php\r\n+\r\n+namespace App\\Http\\Middleware;\r\n+\r\n+use Closure;\r\n+use Illuminate\\Http\\Request;\r\n+use SebastianBergmann\\Type\\Exception;\r\n+use Symfony\\Component\\HttpFoundation\\Response;\r\n+use Anasa\\ResponseStrategy\\ResponseStrategyFactory;\r\n+use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n+use Anasa\\ResponseStrategy\\Facades\\AdditionalDataRequest;\r\n+\r\n+class ApiOrWebMiddleware\r\n+{\r\n+    public function __construct(protected ResponseContextInterface $responseContext)\r\n+    {\r\n+    }\r\n+\r\n+    /**\r\n+     * Handle an incoming request.\r\n+     *\r\n+     * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response)  $next\r\n+     */\r\n+    public function handle(Request $request, Closure $next): Response\r\n+    {\r\n+        /**\r\n+         * Set additional data request:\r\n+         * this will add the controller, method, view and resource. It's\r\n+         * some dinamic data to be used in the strategy to identify and build\r\n+         * the response. A facade will be used.\r\n+         */\r\n+        $this->setAdditionalDataRequest($request);\r\n+\r\n+        $this->defineResponseStrategy();\r\n+\r\n+        return $next($request);\r\n+    }\r\n+\r\n+    private function setAdditionalDataRequest(Request $request): void\r\n+    {\r\n+        $action = $request->route()->getAction();\r\n+        $controller = class_basename($action['controller']);\r\n+        [, $methodName] = explode('@', $controller);\r\n+\r\n+        /**\r\n+         * facades, the intentions is to have a dinamic data abaliable for all app\r\n+         *  without need to create dependencies\r\n+         **/\r\n+\r\n+        AdditionalDataRequest::setMethod($request->expectsJson() || $request->is('api/*') ? 'API' : $methodName);\r\n+        AdditionalDataRequest::setView($request->route()->getName());\r\n+        AdditionalDataRequest::setRoute($request->route()->getName());\r\n+    }\r\n+\r\n+    /**\r\n+     * Used factory design patterns to create the response strategy.\r\n+     */\r\n+    public function defineResponseStrategy()\r\n+    {\r\n+        try {\r\n+            //Factory Method, returns a concrete instance based on the ResponseStrategy interface.\r\n+            $strategy = ResponseStrategyFactory::createStrategy(AdditionalDataRequest::getMethod());\r\n+        } catch (Exception $e) {\r\n+            throw new Exception('Unknown method');\r\n+        }\r\n+\r\n+        $this->responseContext->setStrategy($strategy);\r\n+    }\r\n+}\r\n+\r\n+```\r\n+**Notes:**\r\n+- setMethod will set as API for all input\r\n+- If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n+```php\r\n+AdditionalDataRequest::setMethod($request->expectsJson() || $request->is('api/*') ? 'API' : $methodName);\r\n+```\r\n+\r\n+2- Set Service Provider and Response Service provider,\r\n+\r\n+```php\r\n+<?php\r\n+\r\n+namespace App\\Providers;\r\n+\r\n+use Illuminate\\Support\\ServiceProvider;\r\n+use Anasa\\ResponseStrategy\\AdditionalDataRequest;\r\n+\r\n+class AppServiceProvider extends ServiceProvider\r\n+{\r\n+    /**\r\n+     * Register any application services.\r\n+     */\r\n+    public function register(): void\r\n+    {\r\n+        //...\r\n+        $this->app->singleton('additionalDataRequest', function ($app) {\r\n+            return new AdditionalDataRequest;\r\n+        });\r\n+    }\r\n+\r\n+    /**\r\n+     * Bootstrap any application services.\r\n+     */\r\n+    public function boot(): void\r\n+    {\r\n+       //\r\n+    }\r\n+}\r\n+\r\n+```\r\n+\r\n+```php\r\n+<?php\r\n+\r\n+namespace App\\Providers;\r\n+\r\n+use Illuminate\\Support\\ServiceProvider;\r\n+use Anasa\\ResponseStrategy\\ResponseContext;\r\n+use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n+use Anasa\\ResponseStrategy\\Output\\ApiResponseStrategy;\r\n+use Anasa\\ResponseStrategy\\Output\\ViewResponseStrategy;\r\n+use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyData;\r\n+use Anasa\\ResponseStrategy\\Output\\RedirectResponseStrategy;\r\n+use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyDataInterface;\r\n+\r\n+class ResponseServiceProvider extends ServiceProvider\r\n+{\r\n+    public function register()\r\n+    {\r\n+        $this->app->bind(ApiResponseStrategy::class, function ($app) {\r\n+            return new ApiResponseStrategy();\r\n+        });\r\n+\r\n+        $this->app->bind(ViewResponseStrategy::class, function ($app) {\r\n+            return new ViewResponseStrategy();\r\n+        });\r\n+\r\n+        $this->app->bind(RedirectResponseStrategy::class, function ($app) {\r\n+            return new RedirectResponseStrategy();\r\n+        });\r\n+        $this->app->bind(StrategyDataInterface::class, function ($app) {\r\n+            return new StrategyData();\r\n+        });\r\n+\r\n+        $this->app->singleton(ResponseContextInterface::class, function ($app) {\r\n+            return new ResponseContext();\r\n+        });\r\n+    }\r\n+}\r\n+\r\n+```\r\n+\r\n+3- Using it in your controller\r\n+\r\n+```php\r\n+<?php\r\n+\r\n+namespace App\\Http\\Controllers;\r\n+\r\n+use Illuminate\\Http\\JsonResponse;\r\n+use Illuminate\\Contracts\\View\\View;\r\n+use App\\Http\\Controllers\\Controller;\r\n+use App\\Http\\Requests\\GatewayRequest;\r\n+use App\\Http\\Resources\\GatewayResource;\r\n+use App\\Repositories\\CrudRepositoryInterface;\r\n+use Symfony\\Component\\HttpFoundation\\Response;\r\n+use Symfony\\Component\\HttpFoundation\\RedirectResponse;\r\n+use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n+use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyDataInterface;\r\n+\r\n+class GatewayController extends Controller\r\n+{\r\n+    public function __construct(protected CrudRepositoryInterface $repository, protected ResponseContextInterface $responseContext, protected StrategyDataInterface $strategyData)\r\n+    {\r\n+    }\r\n+\r\n+    /**\r\n+     * @todo The view is not implemented\r\n+     */\r\n+    public function index(): View|JsonResponse\r\n+    {\r\n+        $data = $this->repository->all();\r\n+        $strategy = $this->strategyData->setStrategyData(GatewayResource::collection($gateway));\r\n+        return $this->responseContext->executeStrategy($strategy);\r\n+    }\r\n+```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725259717136,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -189,174 +189,8 @@\n      */\r\n     public function index(): View|JsonResponse\r\n     {\r\n         $data = $this->repository->all();\r\n-        $strategy = $this->strategyData->setStrategyData(GatewayResource::collection($gateway));\r\n+        $strategy = $this->strategyData->setStrategyData(YouResource::collection($ga$datateway));\r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n-```\n-# anasa-response-strategy\r\n-Package to isolate the logic that determines the return type of the controller based on the source (API/Web)\r\n-\r\n-This is an optional solution in Laravel to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n-\r\n-## How it works\r\n-1- From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\r\n-\r\n-```php\r\n-<?php\r\n-\r\n-namespace App\\Http\\Middleware;\r\n-\r\n-use Closure;\r\n-use Illuminate\\Http\\Request;\r\n-use SebastianBergmann\\Type\\Exception;\r\n-use Symfony\\Component\\HttpFoundation\\Response;\r\n-use Anasa\\ResponseStrategy\\ResponseStrategyFactory;\r\n-use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n-use Anasa\\ResponseStrategy\\Facades\\AdditionalDataRequest;\r\n-\r\n-class ApiOrWebMiddleware\r\n-{\r\n-    public function __construct(protected ResponseContextInterface $responseContext)\r\n-    {\r\n-    }\r\n-\r\n-    /**\r\n-     * Handle an incoming request.\r\n-     *\r\n-     * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response)  $next\r\n-     */\r\n-    public function handle(Request $request, Closure $next): Response\r\n-    {\r\n-        /**\r\n-         * Set additional data request:\r\n-         * this will add the controller, method, view and resource. It's\r\n-         * some dinamic data to be used in the strategy to identify and build\r\n-         * the response. A facade will be used.\r\n-         */\r\n-        $this->setAdditionalDataRequest($request);\r\n-\r\n-        $this->defineResponseStrategy();\r\n-\r\n-        return $next($request);\r\n-    }\r\n-\r\n-    private function setAdditionalDataRequest(Request $request): void\r\n-    {\r\n-        $action = $request->route()->getAction();\r\n-        $controller = class_basename($action['controller']);\r\n-        [, $methodName] = explode('@', $controller);\r\n-\r\n-        /**\r\n-         * facades, the intentions is to have a dinamic data abaliable for all app\r\n-         *  without need to create dependencies\r\n-         **/\r\n-\r\n-        AdditionalDataRequest::setMethod($request->expectsJson() || $request->is('api/*') ? 'API' : $methodName);\r\n-        AdditionalDataRequest::setView($request->route()->getName());\r\n-        AdditionalDataRequest::setRoute($request->route()->getName());\r\n-    }\r\n-\r\n-    /**\r\n-     * Used factory design patterns to create the response strategy.\r\n-     */\r\n-    public function defineResponseStrategy()\r\n-    {\r\n-        try {\r\n-            //Factory Method, returns a concrete instance based on the ResponseStrategy interface.\r\n-            $strategy = ResponseStrategyFactory::createStrategy(AdditionalDataRequest::getMethod());\r\n-        } catch (Exception $e) {\r\n-            throw new Exception('Unknown method');\r\n-        }\r\n-\r\n-        $this->responseContext->setStrategy($strategy);\r\n-    }\r\n-}\r\n-\r\n-```\r\n-**Notes:**\r\n-- setMethod will set as API for all input\r\n-- If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n-```php\r\n-AdditionalDataRequest::setMethod($request->expectsJson() || $request->is('api/*') ? 'API' : $methodName);\r\n-```\r\n-\r\n-2- Set Service Provider and Response Service provider,\r\n-\r\n-```php\r\n-<?php\r\n-\r\n-namespace App\\Providers;\r\n-\r\n-use Illuminate\\Support\\ServiceProvider;\r\n-use Anasa\\ResponseStrategy\\AdditionalDataRequest;\r\n-\r\n-class AppServiceProvider extends ServiceProvider\r\n-{\r\n-    /**\r\n-     * Register any application services.\r\n-     */\r\n-    public function register(): void\r\n-    {\r\n-        //...\r\n-        $this->app->singleton('additionalDataRequest', function ($app) {\r\n-            return new AdditionalDataRequest;\r\n-        });\r\n-    }\r\n-\r\n-    /**\r\n-     * Bootstrap any application services.\r\n-     */\r\n-    public function boot(): void\r\n-    {\r\n-       //\r\n-    }\r\n-}\r\n-\r\n-```\r\n-\r\n-```php\r\n-<?php\r\n-\r\n-namespace App\\Providers;\r\n-\r\n-use Illuminate\\Support\\ServiceProvider;\r\n-use Anasa\\ResponseStrategy\\ResponseContext;\r\n-use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n-use Anasa\\ResponseStrategy\\Output\\ApiResponseStrategy;\r\n-use Anasa\\ResponseStrategy\\Output\\ViewResponseStrategy;\r\n-use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyData;\r\n-use Anasa\\ResponseStrategy\\Output\\RedirectResponseStrategy;\r\n-use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyDataInterface;\r\n-\r\n-class ResponseServiceProvider extends ServiceProvider\r\n-{\r\n-    public function register()\r\n-    {\r\n-        $this->app->bind(ApiResponseStrategy::class, function ($app) {\r\n-            return new ApiResponseStrategy();\r\n-        });\r\n-\r\n-        $this->app->bind(ViewResponseStrategy::class, function ($app) {\r\n-            return new ViewResponseStrategy();\r\n-        });\r\n-\r\n-        $this->app->bind(RedirectResponseStrategy::class, function ($app) {\r\n-            return new RedirectResponseStrategy();\r\n-        });\r\n-        $this->app->bind(StrategyDataInterface::class, function ($app) {\r\n-            return new StrategyData();\r\n-        });\r\n-\r\n-        $this->app->singleton(ResponseContextInterface::class, function ($app) {\r\n-            return new ResponseContext();\r\n-        });\r\n-    }\r\n-}\r\n-\r\n-```\r\n-\r\n-3- Using it in your controller\r\n-\r\n-```php\r\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725259725455,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -177,9 +177,9 @@\n use Symfony\\Component\\HttpFoundation\\RedirectResponse;\r\n use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyDataInterface;\r\n \r\n-class GatewayController extends Controller\r\n+class YourController extends Controller\r\n {\r\n     public function __construct(protected CrudRepositoryInterface $repository, protected ResponseContextInterface $responseContext, protected StrategyDataInterface $strategyData)\r\n     {\r\n     }\r\n@@ -189,8 +189,8 @@\n      */\r\n     public function index(): View|JsonResponse\r\n     {\r\n         $data = $this->repository->all();\r\n-        $strategy = $this->strategyData->setStrategyData(YouResource::collection($ga$datateway));\r\n+        $strategy = $this->strategyData->setStrategyData(YourResource::collection($ga$datateway));\r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725259737864,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -189,8 +189,8 @@\n      */\r\n     public function index(): View|JsonResponse\r\n     {\r\n         $data = $this->repository->all();\r\n-        $strategy = $this->strategyData->setStrategyData(YourResource::collection($ga$datateway));\r\n+        $strategy = $this->strategyData->setStrategyData(YourResource::collection($data));\r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725259755826,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -169,10 +169,8 @@\n \r\n use Illuminate\\Http\\JsonResponse;\r\n use Illuminate\\Contracts\\View\\View;\r\n use App\\Http\\Controllers\\Controller;\r\n-use App\\Http\\Requests\\GatewayRequest;\r\n-use App\\Http\\Resources\\GatewayResource;\r\n use App\\Repositories\\CrudRepositoryInterface;\r\n use Symfony\\Component\\HttpFoundation\\Response;\r\n use Symfony\\Component\\HttpFoundation\\RedirectResponse;\r\n use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n"
                },
                {
                    "date": 1725259771011,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -170,10 +170,8 @@\n use Illuminate\\Http\\JsonResponse;\r\n use Illuminate\\Contracts\\View\\View;\r\n use App\\Http\\Controllers\\Controller;\r\n use App\\Repositories\\CrudRepositoryInterface;\r\n-use Symfony\\Component\\HttpFoundation\\Response;\r\n-use Symfony\\Component\\HttpFoundation\\RedirectResponse;\r\n use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyDataInterface;\r\n \r\n class YourController extends Controller\r\n"
                },
                {
                    "date": 1725259794948,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -179,11 +179,9 @@\n     public function __construct(protected CrudRepositoryInterface $repository, protected ResponseContextInterface $responseContext, protected StrategyDataInterface $strategyData)\r\n     {\r\n     }\r\n \r\n-    /**\r\n-     * @todo The view is not implemented\r\n-     */\r\n+    \r\n     public function index(): View|JsonResponse\r\n     {\r\n         $data = $this->repository->all();\r\n         $strategy = $this->strategyData->setStrategyData(YourResource::collection($data));\r\n"
                },
                {
                    "date": 1725259824256,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -178,13 +178,22 @@\n {\r\n     public function __construct(protected CrudRepositoryInterface $repository, protected ResponseContextInterface $responseContext, protected StrategyDataInterface $strategyData)\r\n     {\r\n     }\r\n-\r\n     \r\n     public function index(): View|JsonResponse\r\n     {\r\n         $data = $this->repository->all();\r\n         $strategy = $this->strategyData->setStrategyData(YourResource::collection($data));\r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n+\r\n+     public function store(GatewayRequest $request): JsonResponse|RedirectResponse\r\n+    {\r\n+        $validatedData = $request->validated(); //  this is not a validation, it only returns the validated data after be validated from the GatewayRequest\r\n+        $gateway = $this->repository->create($validatedData);\r\n+\r\n+        $strategy = $this->strategyData->setStrategyData(new GatewayResource($gateway), 'Gateway created successfully', Response::HTTP_CREATED);\r\n+\r\n+        return $this->responseContext->executeStrategy($strategy);\r\n+    }\r\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725259830731,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -188,9 +188,9 @@\n     }\r\n \r\n      public function store(GatewayRequest $request): JsonResponse|RedirectResponse\r\n     {\r\n-        $validatedData = $request->validated(); //  this is not a validation, it only returns the validated data after be validated from the GatewayRequest\r\n+        $validatedData = $request->validated(); \r\n         $gateway = $this->repository->create($validatedData);\r\n \r\n         $strategy = $this->strategyData->setStrategyData(new GatewayResource($gateway), 'Gateway created successfully', Response::HTTP_CREATED);\r\n \r\n"
                },
                {
                    "date": 1725259836418,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -186,9 +186,9 @@\n         $strategy = $this->strategyData->setStrategyData(YourResource::collection($data));\r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n \r\n-     public function store(GatewayRequest $request): JsonResponse|RedirectResponse\r\n+     public function store(YourRequest $request): JsonResponse|RedirectResponse\r\n     {\r\n         $validatedData = $request->validated(); \r\n         $gateway = $this->repository->create($validatedData);\r\n \r\n"
                },
                {
                    "date": 1725259851866,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -191,9 +191,9 @@\n     {\r\n         $validatedData = $request->validated(); \r\n         $gateway = $this->repository->create($validatedData);\r\n \r\n-        $strategy = $this->strategyData->setStrategyData(new GatewayResource($gateway), 'Gateway created successfully', Response::HTTP_CREATED);\r\n+        $strategy = $this->strategyData->setStrategyData(new YourResource($gateway), 'Gateway created successfully', Response::HTTP_CREATED);\r\n \r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725259858490,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -189,11 +189,11 @@\n \r\n      public function store(YourRequest $request): JsonResponse|RedirectResponse\r\n     {\r\n         $validatedData = $request->validated(); \r\n-        $gateway = $this->repository->create($validatedData);\r\n+        $data = $this->repository->create($validatedData);\r\n \r\n-        $strategy = $this->strategyData->setStrategyData(new YourResource($gateway), 'Gateway created successfully', Response::HTTP_CREATED);\r\n+        $strategy = $this->strategyData->setStrategyData(new YourResource($data), 'Gateway created successfully', Response::HTTP_CREATED);\r\n \r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725259875315,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -189,9 +189,9 @@\n \r\n      public function store(YourRequest $request): JsonResponse|RedirectResponse\r\n     {\r\n         $validatedData = $request->validated(); \r\n-        $data = $this->repository->create($validatedData);\r\n+        $data = $this->repository->create($request->validated());\r\n \r\n         $strategy = $this->strategyData->setStrategyData(new YourResource($data), 'Gateway created successfully', Response::HTTP_CREATED);\r\n \r\n         return $this->responseContext->executeStrategy($strategy);\r\n"
                },
                {
                    "date": 1725259898542,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -186,11 +186,11 @@\n         $strategy = $this->strategyData->setStrategyData(YourResource::collection($data));\r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n \r\n-     public function store(YourRequest $request): JsonResponse|RedirectResponse\r\n+    public function store(YourRequest $request): JsonResponse|RedirectResponse\r\n     {\r\n-        $validatedData = $request->validated(); \r\n+        \r\n         $data = $this->repository->create($request->validated());\r\n \r\n         $strategy = $this->strategyData->setStrategyData(new YourResource($data), 'Gateway created successfully', Response::HTTP_CREATED);\r\n \r\n"
                },
                {
                    "date": 1725259908825,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -195,5 +195,13 @@\n         $strategy = $this->strategyData->setStrategyData(new YourResource($data), 'Gateway created successfully', Response::HTTP_CREATED);\r\n \r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n+\r\n+     public function show($id): JsonResponse|View\r\n+    {\r\n+        $gateway = $this->repository->find($id); //it uses findOrFail\r\n+        $strategy = $this->strategyData->setStrategyData(new GatewayResource($gateway));\r\n+\r\n+        return $this->responseContext->executeStrategy($strategy);\r\n+    }\r\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725259922464,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -198,10 +198,10 @@\n     }\r\n \r\n      public function show($id): JsonResponse|View\r\n     {\r\n-        $gateway = $this->repository->find($id); //it uses findOrFail\r\n-        $strategy = $this->strategyData->setStrategyData(new GatewayResource($gateway));\r\n+        $data = $this->repository->find($id); //it uses findOrFail\r\n+        $strategy = $this->strategyData->setStrategyData(new GatewayResource($data));\r\n \r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725260286088,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -198,10 +198,10 @@\n     }\r\n \r\n      public function show($id): JsonResponse|View\r\n     {\r\n-        $data = $this->repository->find($id); //it uses findOrFail\r\n-        $strategy = $this->strategyData->setStrategyData(new GatewayResource($data));\r\n+        $data = $this->repository->find($id); //it uses findOrFail from the repo\r\n+        $strategy = $this->strategyData->setStrategyData(new YourResource($data));\r\n \r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725260293489,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -198,9 +198,9 @@\n     }\r\n \r\n      public function show($id): JsonResponse|View\r\n     {\r\n-        $data = $this->repository->find($id); //it uses findOrFail from the repo\r\n+        $data = $this->repository->find($id); //it uses findOrFail from the repository\r\n         $strategy = $this->strategyData->setStrategyData(new YourResource($data));\r\n \r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n"
                },
                {
                    "date": 1725260301599,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -196,9 +196,9 @@\n \r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n \r\n-     public function show($id): JsonResponse|View\r\n+    public function show($id): JsonResponse|View\r\n     {\r\n         $data = $this->repository->find($id); //it uses findOrFail from the repository\r\n         $strategy = $this->strategyData->setStrategyData(new YourResource($data));\r\n \r\n"
                },
                {
                    "date": 1725260316860,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -203,5 +203,15 @@\n         $strategy = $this->strategyData->setStrategyData(new YourResource($data));\r\n \r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n+\r\n+    public function update(GatewayRequest $request, string $id): JsonResponse|RedirectResponse\r\n+    {\r\n+        $validatedData = $request->validated();//  this is not a validation, it only returns the validated data after be validated from the GatewayRequest\r\n+        $updated_data = $this->repository->update($id, $validatedData); //it uses findOrFail\r\n+\r\n+        $strategy = $this->strategyData->setStrategyData(new GatewayResource($updated_data), 'Gateway updated successfully', Response::HTTP_OK);\r\n+\r\n+        return $this->responseContext->executeStrategy($strategy);\r\n+    }\r\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725260325912,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,217 @@\n+# anasa-response-strategy\r\n+Package to isolate the logic that determines the return type of the controller based on the source (API/Web)\r\n+\r\n+This is an optional solution in Laravel to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n+\r\n+## How it works\r\n+1- From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\r\n+\r\n+```php\r\n+<?php\r\n+\r\n+namespace App\\Http\\Middleware;\r\n+\r\n+use Closure;\r\n+use Illuminate\\Http\\Request;\r\n+use SebastianBergmann\\Type\\Exception;\r\n+use Symfony\\Component\\HttpFoundation\\Response;\r\n+use Anasa\\ResponseStrategy\\ResponseStrategyFactory;\r\n+use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n+use Anasa\\ResponseStrategy\\Facades\\AdditionalDataRequest;\r\n+\r\n+class ApiOrWebMiddleware\r\n+{\r\n+    public function __construct(protected ResponseContextInterface $responseContext)\r\n+    {\r\n+    }\r\n+\r\n+    /**\r\n+     * Handle an incoming request.\r\n+     *\r\n+     * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response)  $next\r\n+     */\r\n+    public function handle(Request $request, Closure $next): Response\r\n+    {\r\n+        /**\r\n+         * Set additional data request:\r\n+         * this will add the controller, method, view and resource. It's\r\n+         * some dinamic data to be used in the strategy to identify and build\r\n+         * the response. A facade will be used.\r\n+         */\r\n+        $this->setAdditionalDataRequest($request);\r\n+\r\n+        $this->defineResponseStrategy();\r\n+\r\n+        return $next($request);\r\n+    }\r\n+\r\n+    private function setAdditionalDataRequest(Request $request): void\r\n+    {\r\n+        $action = $request->route()->getAction();\r\n+        $controller = class_basename($action['controller']);\r\n+        [, $methodName] = explode('@', $controller);\r\n+\r\n+        /**\r\n+         * facades, the intentions is to have a dinamic data abaliable for all app\r\n+         *  without need to create dependencies\r\n+         **/\r\n+\r\n+        AdditionalDataRequest::setMethod($request->expectsJson() || $request->is('api/*') ? 'API' : $methodName);\r\n+        AdditionalDataRequest::setView($request->route()->getName());\r\n+        AdditionalDataRequest::setRoute($request->route()->getName());\r\n+    }\r\n+\r\n+    /**\r\n+     * Used factory design patterns to create the response strategy.\r\n+     */\r\n+    public function defineResponseStrategy()\r\n+    {\r\n+        try {\r\n+            //Factory Method, returns a concrete instance based on the ResponseStrategy interface.\r\n+            $strategy = ResponseStrategyFactory::createStrategy(AdditionalDataRequest::getMethod());\r\n+        } catch (Exception $e) {\r\n+            throw new Exception('Unknown method');\r\n+        }\r\n+\r\n+        $this->responseContext->setStrategy($strategy);\r\n+    }\r\n+}\r\n+\r\n+```\r\n+**Notes:**\r\n+- setMethod will set as API for all input\r\n+- If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n+```php\r\n+AdditionalDataRequest::setMethod($request->expectsJson() || $request->is('api/*') ? 'API' : $methodName);\r\n+```\r\n+\r\n+2- Set Service Provider and Response Service provider,\r\n+\r\n+```php\r\n+<?php\r\n+\r\n+namespace App\\Providers;\r\n+\r\n+use Illuminate\\Support\\ServiceProvider;\r\n+use Anasa\\ResponseStrategy\\AdditionalDataRequest;\r\n+\r\n+class AppServiceProvider extends ServiceProvider\r\n+{\r\n+    /**\r\n+     * Register any application services.\r\n+     */\r\n+    public function register(): void\r\n+    {\r\n+        //...\r\n+        $this->app->singleton('additionalDataRequest', function ($app) {\r\n+            return new AdditionalDataRequest;\r\n+        });\r\n+    }\r\n+\r\n+    /**\r\n+     * Bootstrap any application services.\r\n+     */\r\n+    public function boot(): void\r\n+    {\r\n+       //\r\n+    }\r\n+}\r\n+\r\n+```\r\n+\r\n+```php\r\n+<?php\r\n+\r\n+namespace App\\Providers;\r\n+\r\n+use Illuminate\\Support\\ServiceProvider;\r\n+use Anasa\\ResponseStrategy\\ResponseContext;\r\n+use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n+use Anasa\\ResponseStrategy\\Output\\ApiResponseStrategy;\r\n+use Anasa\\ResponseStrategy\\Output\\ViewResponseStrategy;\r\n+use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyData;\r\n+use Anasa\\ResponseStrategy\\Output\\RedirectResponseStrategy;\r\n+use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyDataInterface;\r\n+\r\n+class ResponseServiceProvider extends ServiceProvider\r\n+{\r\n+    public function register()\r\n+    {\r\n+        $this->app->bind(ApiResponseStrategy::class, function ($app) {\r\n+            return new ApiResponseStrategy();\r\n+        });\r\n+\r\n+        $this->app->bind(ViewResponseStrategy::class, function ($app) {\r\n+            return new ViewResponseStrategy();\r\n+        });\r\n+\r\n+        $this->app->bind(RedirectResponseStrategy::class, function ($app) {\r\n+            return new RedirectResponseStrategy();\r\n+        });\r\n+        $this->app->bind(StrategyDataInterface::class, function ($app) {\r\n+            return new StrategyData();\r\n+        });\r\n+\r\n+        $this->app->singleton(ResponseContextInterface::class, function ($app) {\r\n+            return new ResponseContext();\r\n+        });\r\n+    }\r\n+}\r\n+\r\n+```\r\n+\r\n+3- Using it in your controller\r\n+\r\n+```php\r\n+<?php\r\n+\r\n+namespace App\\Http\\Controllers;\r\n+\r\n+use Illuminate\\Http\\JsonResponse;\r\n+use Illuminate\\Contracts\\View\\View;\r\n+use App\\Http\\Controllers\\Controller;\r\n+use App\\Repositories\\CrudRepositoryInterface;\r\n+use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n+use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyDataInterface;\r\n+\r\n+class YourController extends Controller\r\n+{\r\n+    public function __construct(protected CrudRepositoryInterface $repository, protected ResponseContextInterface $responseContext, protected StrategyDataInterface $strategyData)\r\n+    {\r\n+    }\r\n+    \r\n+    public function index(): View|JsonResponse\r\n+    {\r\n+        $data = $this->repository->all();\r\n+        $strategy = $this->strategyData->setStrategyData(YourResource::collection($data));\r\n+        return $this->responseContext->executeStrategy($strategy);\r\n+    }\r\n+\r\n+    public function store(YourRequest $request): JsonResponse|RedirectResponse\r\n+    {\r\n+        \r\n+        $data = $this->repository->create($request->validated());\r\n+\r\n+        $strategy = $this->strategyData->setStrategyData(new YourResource($data), 'Gateway created successfully', Response::HTTP_CREATED);\r\n+\r\n+        return $this->responseContext->executeStrategy($strategy);\r\n+    }\r\n+\r\n+    public function show($id): JsonResponse|View\r\n+    {\r\n+        $data = $this->repository->find($id); //it uses findOrFail from the repository\r\n+        $strategy = $this->strategyData->setStrategyData(new YourResource($data));\r\n+\r\n+        return $this->responseContext->executeStrategy($strategy);\r\n+    }\r\n+\r\n+    public function update(GatewayRequest $request, string $id): JsonResponse|RedirectResponse\r\n+    {\r\n+        $validatedData = $request->validated();//  this is not a validation, it only returns the validated data after be validated from the GatewayRequest\r\n+        $updated_data = $this->repository->update($id, $request->validated()); //it uses findOrFail\r\n+\r\n+        $strategy = $this->strategyData->setStrategyData(new GatewayResource($updated_data), 'Gateway updated successfully', Response::HTTP_OK);\r\n+\r\n+        return $this->responseContext->executeStrategy($strategy);\r\n+    }\r\n+```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725260336263,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -204,231 +204,14 @@\n \r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n \r\n-    public function update(GatewayRequest $request, string $id): JsonResponse|RedirectResponse\r\n+    public function update(YourRequest $request, string $id): JsonResponse|RedirectResponse\r\n     {\r\n-        $validatedData = $request->validated();//  this is not a validation, it only returns the validated data after be validated from the GatewayRequest\r\n+        \r\n         $updated_data = $this->repository->update($id, $request->validated()); //it uses findOrFail\r\n \r\n         $strategy = $this->strategyData->setStrategyData(new GatewayResource($updated_data), 'Gateway updated successfully', Response::HTTP_OK);\r\n \r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n-```\n-# anasa-response-strategy\r\n-Package to isolate the logic that determines the return type of the controller based on the source (API/Web)\r\n-\r\n-This is an optional solution in Laravel to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n-\r\n-## How it works\r\n-1- From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\r\n-\r\n-```php\r\n-<?php\r\n-\r\n-namespace App\\Http\\Middleware;\r\n-\r\n-use Closure;\r\n-use Illuminate\\Http\\Request;\r\n-use SebastianBergmann\\Type\\Exception;\r\n-use Symfony\\Component\\HttpFoundation\\Response;\r\n-use Anasa\\ResponseStrategy\\ResponseStrategyFactory;\r\n-use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n-use Anasa\\ResponseStrategy\\Facades\\AdditionalDataRequest;\r\n-\r\n-class ApiOrWebMiddleware\r\n-{\r\n-    public function __construct(protected ResponseContextInterface $responseContext)\r\n-    {\r\n-    }\r\n-\r\n-    /**\r\n-     * Handle an incoming request.\r\n-     *\r\n-     * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response)  $next\r\n-     */\r\n-    public function handle(Request $request, Closure $next): Response\r\n-    {\r\n-        /**\r\n-         * Set additional data request:\r\n-         * this will add the controller, method, view and resource. It's\r\n-         * some dinamic data to be used in the strategy to identify and build\r\n-         * the response. A facade will be used.\r\n-         */\r\n-        $this->setAdditionalDataRequest($request);\r\n-\r\n-        $this->defineResponseStrategy();\r\n-\r\n-        return $next($request);\r\n-    }\r\n-\r\n-    private function setAdditionalDataRequest(Request $request): void\r\n-    {\r\n-        $action = $request->route()->getAction();\r\n-        $controller = class_basename($action['controller']);\r\n-        [, $methodName] = explode('@', $controller);\r\n-\r\n-        /**\r\n-         * facades, the intentions is to have a dinamic data abaliable for all app\r\n-         *  without need to create dependencies\r\n-         **/\r\n-\r\n-        AdditionalDataRequest::setMethod($request->expectsJson() || $request->is('api/*') ? 'API' : $methodName);\r\n-        AdditionalDataRequest::setView($request->route()->getName());\r\n-        AdditionalDataRequest::setRoute($request->route()->getName());\r\n-    }\r\n-\r\n-    /**\r\n-     * Used factory design patterns to create the response strategy.\r\n-     */\r\n-    public function defineResponseStrategy()\r\n-    {\r\n-        try {\r\n-            //Factory Method, returns a concrete instance based on the ResponseStrategy interface.\r\n-            $strategy = ResponseStrategyFactory::createStrategy(AdditionalDataRequest::getMethod());\r\n-        } catch (Exception $e) {\r\n-            throw new Exception('Unknown method');\r\n-        }\r\n-\r\n-        $this->responseContext->setStrategy($strategy);\r\n-    }\r\n-}\r\n-\r\n-```\r\n-**Notes:**\r\n-- setMethod will set as API for all input\r\n-- If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n-```php\r\n-AdditionalDataRequest::setMethod($request->expectsJson() || $request->is('api/*') ? 'API' : $methodName);\r\n-```\r\n-\r\n-2- Set Service Provider and Response Service provider,\r\n-\r\n-```php\r\n-<?php\r\n-\r\n-namespace App\\Providers;\r\n-\r\n-use Illuminate\\Support\\ServiceProvider;\r\n-use Anasa\\ResponseStrategy\\AdditionalDataRequest;\r\n-\r\n-class AppServiceProvider extends ServiceProvider\r\n-{\r\n-    /**\r\n-     * Register any application services.\r\n-     */\r\n-    public function register(): void\r\n-    {\r\n-        //...\r\n-        $this->app->singleton('additionalDataRequest', function ($app) {\r\n-            return new AdditionalDataRequest;\r\n-        });\r\n-    }\r\n-\r\n-    /**\r\n-     * Bootstrap any application services.\r\n-     */\r\n-    public function boot(): void\r\n-    {\r\n-       //\r\n-    }\r\n-}\r\n-\r\n-```\r\n-\r\n-```php\r\n-<?php\r\n-\r\n-namespace App\\Providers;\r\n-\r\n-use Illuminate\\Support\\ServiceProvider;\r\n-use Anasa\\ResponseStrategy\\ResponseContext;\r\n-use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n-use Anasa\\ResponseStrategy\\Output\\ApiResponseStrategy;\r\n-use Anasa\\ResponseStrategy\\Output\\ViewResponseStrategy;\r\n-use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyData;\r\n-use Anasa\\ResponseStrategy\\Output\\RedirectResponseStrategy;\r\n-use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyDataInterface;\r\n-\r\n-class ResponseServiceProvider extends ServiceProvider\r\n-{\r\n-    public function register()\r\n-    {\r\n-        $this->app->bind(ApiResponseStrategy::class, function ($app) {\r\n-            return new ApiResponseStrategy();\r\n-        });\r\n-\r\n-        $this->app->bind(ViewResponseStrategy::class, function ($app) {\r\n-            return new ViewResponseStrategy();\r\n-        });\r\n-\r\n-        $this->app->bind(RedirectResponseStrategy::class, function ($app) {\r\n-            return new RedirectResponseStrategy();\r\n-        });\r\n-        $this->app->bind(StrategyDataInterface::class, function ($app) {\r\n-            return new StrategyData();\r\n-        });\r\n-\r\n-        $this->app->singleton(ResponseContextInterface::class, function ($app) {\r\n-            return new ResponseContext();\r\n-        });\r\n-    }\r\n-}\r\n-\r\n-```\r\n-\r\n-3- Using it in your controller\r\n-\r\n-```php\r\n-<?php\r\n-\r\n-namespace App\\Http\\Controllers;\r\n-\r\n-use Illuminate\\Http\\JsonResponse;\r\n-use Illuminate\\Contracts\\View\\View;\r\n-use App\\Http\\Controllers\\Controller;\r\n-use App\\Repositories\\CrudRepositoryInterface;\r\n-use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n-use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyDataInterface;\r\n-\r\n-class YourController extends Controller\r\n-{\r\n-    public function __construct(protected CrudRepositoryInterface $repository, protected ResponseContextInterface $responseContext, protected StrategyDataInterface $strategyData)\r\n-    {\r\n-    }\r\n-    \r\n-    public function index(): View|JsonResponse\r\n-    {\r\n-        $data = $this->repository->all();\r\n-        $strategy = $this->strategyData->setStrategyData(YourResource::collection($data));\r\n-        return $this->responseContext->executeStrategy($strategy);\r\n-    }\r\n-\r\n-    public function store(YourRequest $request): JsonResponse|RedirectResponse\r\n-    {\r\n-        \r\n-        $data = $this->repository->create($request->validated());\r\n-\r\n-        $strategy = $this->strategyData->setStrategyData(new YourResource($data), 'Gateway created successfully', Response::HTTP_CREATED);\r\n-\r\n-        return $this->responseContext->executeStrategy($strategy);\r\n-    }\r\n-\r\n-    public function show($id): JsonResponse|View\r\n-    {\r\n-        $data = $this->repository->find($id); //it uses findOrFail from the repository\r\n-        $strategy = $this->strategyData->setStrategyData(new YourResource($data));\r\n-\r\n-        return $this->responseContext->executeStrategy($strategy);\r\n-    }\r\n-\r\n-    public function update(GatewayRequest $request, string $id): JsonResponse|RedirectResponse\r\n-    {\r\n-        $validatedData = $request->validated();//  this is not a validation, it only returns the validated data after be validated from the GatewayRequest\r\n-        $updated_data = $this->repository->update($id, $validatedData); //it uses findOrFail\r\n-\r\n-        $strategy = $this->strategyData->setStrategyData(new GatewayResource($updated_data), 'Gateway updated successfully', Response::HTTP_OK);\r\n-\r\n-        return $this->responseContext->executeStrategy($strategy);\r\n-    }\r\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725260342684,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,217 @@\n+# anasa-response-strategy\r\n+Package to isolate the logic that determines the return type of the controller based on the source (API/Web)\r\n+\r\n+This is an optional solution in Laravel to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n+\r\n+## How it works\r\n+1- From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\r\n+\r\n+```php\r\n+<?php\r\n+\r\n+namespace App\\Http\\Middleware;\r\n+\r\n+use Closure;\r\n+use Illuminate\\Http\\Request;\r\n+use SebastianBergmann\\Type\\Exception;\r\n+use Symfony\\Component\\HttpFoundation\\Response;\r\n+use Anasa\\ResponseStrategy\\ResponseStrategyFactory;\r\n+use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n+use Anasa\\ResponseStrategy\\Facades\\AdditionalDataRequest;\r\n+\r\n+class ApiOrWebMiddleware\r\n+{\r\n+    public function __construct(protected ResponseContextInterface $responseContext)\r\n+    {\r\n+    }\r\n+\r\n+    /**\r\n+     * Handle an incoming request.\r\n+     *\r\n+     * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response)  $next\r\n+     */\r\n+    public function handle(Request $request, Closure $next): Response\r\n+    {\r\n+        /**\r\n+         * Set additional data request:\r\n+         * this will add the controller, method, view and resource. It's\r\n+         * some dinamic data to be used in the strategy to identify and build\r\n+         * the response. A facade will be used.\r\n+         */\r\n+        $this->setAdditionalDataRequest($request);\r\n+\r\n+        $this->defineResponseStrategy();\r\n+\r\n+        return $next($request);\r\n+    }\r\n+\r\n+    private function setAdditionalDataRequest(Request $request): void\r\n+    {\r\n+        $action = $request->route()->getAction();\r\n+        $controller = class_basename($action['controller']);\r\n+        [, $methodName] = explode('@', $controller);\r\n+\r\n+        /**\r\n+         * facades, the intentions is to have a dinamic data abaliable for all app\r\n+         *  without need to create dependencies\r\n+         **/\r\n+\r\n+        AdditionalDataRequest::setMethod($request->expectsJson() || $request->is('api/*') ? 'API' : $methodName);\r\n+        AdditionalDataRequest::setView($request->route()->getName());\r\n+        AdditionalDataRequest::setRoute($request->route()->getName());\r\n+    }\r\n+\r\n+    /**\r\n+     * Used factory design patterns to create the response strategy.\r\n+     */\r\n+    public function defineResponseStrategy()\r\n+    {\r\n+        try {\r\n+            //Factory Method, returns a concrete instance based on the ResponseStrategy interface.\r\n+            $strategy = ResponseStrategyFactory::createStrategy(AdditionalDataRequest::getMethod());\r\n+        } catch (Exception $e) {\r\n+            throw new Exception('Unknown method');\r\n+        }\r\n+\r\n+        $this->responseContext->setStrategy($strategy);\r\n+    }\r\n+}\r\n+\r\n+```\r\n+**Notes:**\r\n+- setMethod will set as API for all input\r\n+- If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n+```php\r\n+AdditionalDataRequest::setMethod($request->expectsJson() || $request->is('api/*') ? 'API' : $methodName);\r\n+```\r\n+\r\n+2- Set Service Provider and Response Service provider,\r\n+\r\n+```php\r\n+<?php\r\n+\r\n+namespace App\\Providers;\r\n+\r\n+use Illuminate\\Support\\ServiceProvider;\r\n+use Anasa\\ResponseStrategy\\AdditionalDataRequest;\r\n+\r\n+class AppServiceProvider extends ServiceProvider\r\n+{\r\n+    /**\r\n+     * Register any application services.\r\n+     */\r\n+    public function register(): void\r\n+    {\r\n+        //...\r\n+        $this->app->singleton('additionalDataRequest', function ($app) {\r\n+            return new AdditionalDataRequest;\r\n+        });\r\n+    }\r\n+\r\n+    /**\r\n+     * Bootstrap any application services.\r\n+     */\r\n+    public function boot(): void\r\n+    {\r\n+       //\r\n+    }\r\n+}\r\n+\r\n+```\r\n+\r\n+```php\r\n+<?php\r\n+\r\n+namespace App\\Providers;\r\n+\r\n+use Illuminate\\Support\\ServiceProvider;\r\n+use Anasa\\ResponseStrategy\\ResponseContext;\r\n+use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n+use Anasa\\ResponseStrategy\\Output\\ApiResponseStrategy;\r\n+use Anasa\\ResponseStrategy\\Output\\ViewResponseStrategy;\r\n+use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyData;\r\n+use Anasa\\ResponseStrategy\\Output\\RedirectResponseStrategy;\r\n+use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyDataInterface;\r\n+\r\n+class ResponseServiceProvider extends ServiceProvider\r\n+{\r\n+    public function register()\r\n+    {\r\n+        $this->app->bind(ApiResponseStrategy::class, function ($app) {\r\n+            return new ApiResponseStrategy();\r\n+        });\r\n+\r\n+        $this->app->bind(ViewResponseStrategy::class, function ($app) {\r\n+            return new ViewResponseStrategy();\r\n+        });\r\n+\r\n+        $this->app->bind(RedirectResponseStrategy::class, function ($app) {\r\n+            return new RedirectResponseStrategy();\r\n+        });\r\n+        $this->app->bind(StrategyDataInterface::class, function ($app) {\r\n+            return new StrategyData();\r\n+        });\r\n+\r\n+        $this->app->singleton(ResponseContextInterface::class, function ($app) {\r\n+            return new ResponseContext();\r\n+        });\r\n+    }\r\n+}\r\n+\r\n+```\r\n+\r\n+3- Using it in your controller\r\n+\r\n+```php\r\n+<?php\r\n+\r\n+namespace App\\Http\\Controllers;\r\n+\r\n+use Illuminate\\Http\\JsonResponse;\r\n+use Illuminate\\Contracts\\View\\View;\r\n+use App\\Http\\Controllers\\Controller;\r\n+use App\\Repositories\\CrudRepositoryInterface;\r\n+use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n+use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyDataInterface;\r\n+\r\n+class YourController extends Controller\r\n+{\r\n+    public function __construct(protected CrudRepositoryInterface $repository, protected ResponseContextInterface $responseContext, protected StrategyDataInterface $strategyData)\r\n+    {\r\n+    }\r\n+    \r\n+    public function index(): View|JsonResponse\r\n+    {\r\n+        $data = $this->repository->all();\r\n+        $strategy = $this->strategyData->setStrategyData(YourResource::collection($data));\r\n+        return $this->responseContext->executeStrategy($strategy);\r\n+    }\r\n+\r\n+    public function store(YourRequest $request): JsonResponse|RedirectResponse\r\n+    {\r\n+        \r\n+        $data = $this->repository->create($request->validated());\r\n+\r\n+        $strategy = $this->strategyData->setStrategyData(new YourResource($data), 'Gateway created successfully', Response::HTTP_CREATED);\r\n+\r\n+        return $this->responseContext->executeStrategy($strategy);\r\n+    }\r\n+\r\n+    public function show($id): JsonResponse|View\r\n+    {\r\n+        $data = $this->repository->find($id); //it uses findOrFail from the repository\r\n+        $strategy = $this->strategyData->setStrategyData(new YourResource($data));\r\n+\r\n+        return $this->responseContext->executeStrategy($strategy);\r\n+    }\r\n+\r\n+    public function update(YourRequest $request, string $id): JsonResponse|RedirectResponse\r\n+    {\r\n+        \r\n+        $updated_data = $this->repository->update($id, $request->validated()); //it uses findOrFail\r\n+\r\n+        $strategy = $this->strategyData->setStrategyData(new YourResource($updated_data), 'Gateway updated successfully', Response::HTTP_OK);\r\n+\r\n+        return $this->responseContext->executeStrategy($strategy);\r\n+    }\r\n+```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725260348058,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -209,226 +209,9 @@\n     {\r\n         \r\n         $updated_data = $this->repository->update($id, $request->validated()); //it uses findOrFail\r\n \r\n-        $strategy = $this->strategyData->setStrategyData(new YourResource($updated_data), 'Gateway updated successfully', Response::HTTP_OK);\r\n+        $strategy = $this->strategyData->setStrategyData(new YourResource($updated_data), 'YourResource updated successfully', Response::HTTP_OK);\r\n \r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n-```\n-# anasa-response-strategy\r\n-Package to isolate the logic that determines the return type of the controller based on the source (API/Web)\r\n-\r\n-This is an optional solution in Laravel to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n-\r\n-## How it works\r\n-1- From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\r\n-\r\n-```php\r\n-<?php\r\n-\r\n-namespace App\\Http\\Middleware;\r\n-\r\n-use Closure;\r\n-use Illuminate\\Http\\Request;\r\n-use SebastianBergmann\\Type\\Exception;\r\n-use Symfony\\Component\\HttpFoundation\\Response;\r\n-use Anasa\\ResponseStrategy\\ResponseStrategyFactory;\r\n-use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n-use Anasa\\ResponseStrategy\\Facades\\AdditionalDataRequest;\r\n-\r\n-class ApiOrWebMiddleware\r\n-{\r\n-    public function __construct(protected ResponseContextInterface $responseContext)\r\n-    {\r\n-    }\r\n-\r\n-    /**\r\n-     * Handle an incoming request.\r\n-     *\r\n-     * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response)  $next\r\n-     */\r\n-    public function handle(Request $request, Closure $next): Response\r\n-    {\r\n-        /**\r\n-         * Set additional data request:\r\n-         * this will add the controller, method, view and resource. It's\r\n-         * some dinamic data to be used in the strategy to identify and build\r\n-         * the response. A facade will be used.\r\n-         */\r\n-        $this->setAdditionalDataRequest($request);\r\n-\r\n-        $this->defineResponseStrategy();\r\n-\r\n-        return $next($request);\r\n-    }\r\n-\r\n-    private function setAdditionalDataRequest(Request $request): void\r\n-    {\r\n-        $action = $request->route()->getAction();\r\n-        $controller = class_basename($action['controller']);\r\n-        [, $methodName] = explode('@', $controller);\r\n-\r\n-        /**\r\n-         * facades, the intentions is to have a dinamic data abaliable for all app\r\n-         *  without need to create dependencies\r\n-         **/\r\n-\r\n-        AdditionalDataRequest::setMethod($request->expectsJson() || $request->is('api/*') ? 'API' : $methodName);\r\n-        AdditionalDataRequest::setView($request->route()->getName());\r\n-        AdditionalDataRequest::setRoute($request->route()->getName());\r\n-    }\r\n-\r\n-    /**\r\n-     * Used factory design patterns to create the response strategy.\r\n-     */\r\n-    public function defineResponseStrategy()\r\n-    {\r\n-        try {\r\n-            //Factory Method, returns a concrete instance based on the ResponseStrategy interface.\r\n-            $strategy = ResponseStrategyFactory::createStrategy(AdditionalDataRequest::getMethod());\r\n-        } catch (Exception $e) {\r\n-            throw new Exception('Unknown method');\r\n-        }\r\n-\r\n-        $this->responseContext->setStrategy($strategy);\r\n-    }\r\n-}\r\n-\r\n-```\r\n-**Notes:**\r\n-- setMethod will set as API for all input\r\n-- If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n-```php\r\n-AdditionalDataRequest::setMethod($request->expectsJson() || $request->is('api/*') ? 'API' : $methodName);\r\n-```\r\n-\r\n-2- Set Service Provider and Response Service provider,\r\n-\r\n-```php\r\n-<?php\r\n-\r\n-namespace App\\Providers;\r\n-\r\n-use Illuminate\\Support\\ServiceProvider;\r\n-use Anasa\\ResponseStrategy\\AdditionalDataRequest;\r\n-\r\n-class AppServiceProvider extends ServiceProvider\r\n-{\r\n-    /**\r\n-     * Register any application services.\r\n-     */\r\n-    public function register(): void\r\n-    {\r\n-        //...\r\n-        $this->app->singleton('additionalDataRequest', function ($app) {\r\n-            return new AdditionalDataRequest;\r\n-        });\r\n-    }\r\n-\r\n-    /**\r\n-     * Bootstrap any application services.\r\n-     */\r\n-    public function boot(): void\r\n-    {\r\n-       //\r\n-    }\r\n-}\r\n-\r\n-```\r\n-\r\n-```php\r\n-<?php\r\n-\r\n-namespace App\\Providers;\r\n-\r\n-use Illuminate\\Support\\ServiceProvider;\r\n-use Anasa\\ResponseStrategy\\ResponseContext;\r\n-use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n-use Anasa\\ResponseStrategy\\Output\\ApiResponseStrategy;\r\n-use Anasa\\ResponseStrategy\\Output\\ViewResponseStrategy;\r\n-use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyData;\r\n-use Anasa\\ResponseStrategy\\Output\\RedirectResponseStrategy;\r\n-use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyDataInterface;\r\n-\r\n-class ResponseServiceProvider extends ServiceProvider\r\n-{\r\n-    public function register()\r\n-    {\r\n-        $this->app->bind(ApiResponseStrategy::class, function ($app) {\r\n-            return new ApiResponseStrategy();\r\n-        });\r\n-\r\n-        $this->app->bind(ViewResponseStrategy::class, function ($app) {\r\n-            return new ViewResponseStrategy();\r\n-        });\r\n-\r\n-        $this->app->bind(RedirectResponseStrategy::class, function ($app) {\r\n-            return new RedirectResponseStrategy();\r\n-        });\r\n-        $this->app->bind(StrategyDataInterface::class, function ($app) {\r\n-            return new StrategyData();\r\n-        });\r\n-\r\n-        $this->app->singleton(ResponseContextInterface::class, function ($app) {\r\n-            return new ResponseContext();\r\n-        });\r\n-    }\r\n-}\r\n-\r\n-```\r\n-\r\n-3- Using it in your controller\r\n-\r\n-```php\r\n-<?php\r\n-\r\n-namespace App\\Http\\Controllers;\r\n-\r\n-use Illuminate\\Http\\JsonResponse;\r\n-use Illuminate\\Contracts\\View\\View;\r\n-use App\\Http\\Controllers\\Controller;\r\n-use App\\Repositories\\CrudRepositoryInterface;\r\n-use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n-use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyDataInterface;\r\n-\r\n-class YourController extends Controller\r\n-{\r\n-    public function __construct(protected CrudRepositoryInterface $repository, protected ResponseContextInterface $responseContext, protected StrategyDataInterface $strategyData)\r\n-    {\r\n-    }\r\n-    \r\n-    public function index(): View|JsonResponse\r\n-    {\r\n-        $data = $this->repository->all();\r\n-        $strategy = $this->strategyData->setStrategyData(YourResource::collection($data));\r\n-        return $this->responseContext->executeStrategy($strategy);\r\n-    }\r\n-\r\n-    public function store(YourRequest $request): JsonResponse|RedirectResponse\r\n-    {\r\n-        \r\n-        $data = $this->repository->create($request->validated());\r\n-\r\n-        $strategy = $this->strategyData->setStrategyData(new YourResource($data), 'Gateway created successfully', Response::HTTP_CREATED);\r\n-\r\n-        return $this->responseContext->executeStrategy($strategy);\r\n-    }\r\n-\r\n-    public function show($id): JsonResponse|View\r\n-    {\r\n-        $data = $this->repository->find($id); //it uses findOrFail from the repository\r\n-        $strategy = $this->strategyData->setStrategyData(new YourResource($data));\r\n-\r\n-        return $this->responseContext->executeStrategy($strategy);\r\n-    }\r\n-\r\n-    public function update(YourRequest $request, string $id): JsonResponse|RedirectResponse\r\n-    {\r\n-        \r\n-        $updated_data = $this->repository->update($id, $request->validated()); //it uses findOrFail\r\n-\r\n-        $strategy = $this->strategyData->setStrategyData(new GatewayResource($updated_data), 'Gateway updated successfully', Response::HTTP_OK);\r\n-\r\n-        return $this->responseContext->executeStrategy($strategy);\r\n-    }\r\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725260371165,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -191,9 +191,9 @@\n     {\r\n         \r\n         $data = $this->repository->create($request->validated());\r\n \r\n-        $strategy = $this->strategyData->setStrategyData(new YourResource($data), 'Gateway created successfully', Response::HTTP_CREATED);\r\n+        $strategy = $this->strategyData->setStrategyData(new YourResource($data), 'YourResource created successfully', Response::HTTP_CREATED);\r\n \r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n \r\n@@ -208,9 +208,8 @@\n     public function update(YourRequest $request, string $id): JsonResponse|RedirectResponse\r\n     {\r\n         \r\n         $updated_data = $this->repository->update($id, $request->validated()); //it uses findOrFail\r\n-\r\n         $strategy = $this->strategyData->setStrategyData(new YourResource($updated_data), 'YourResource updated successfully', Response::HTTP_OK);\r\n \r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n"
                },
                {
                    "date": 1725260398880,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -206,11 +206,11 @@\n     }\r\n \r\n     public function update(YourRequest $request, string $id): JsonResponse|RedirectResponse\r\n     {\r\n-        \r\n         $updated_data = $this->repository->update($id, $request->validated()); //it uses findOrFail\r\n         $strategy = $this->strategyData->setStrategyData(new YourResource($updated_data), 'YourResource updated successfully', Response::HTTP_OK);\r\n \r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n+    \r\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725260409524,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -211,6 +211,12 @@\n         $strategy = $this->strategyData->setStrategyData(new YourResource($updated_data), 'YourResource updated successfully', Response::HTTP_OK);\r\n \r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n-    \r\n+\r\n+    public function destroy($id): JsonResponse|RedirectResponse\r\n+    {\r\n+        $this->repository->delete($id); //it uses findOrFail\r\n+\r\n+        return $this->responseContext->executeStrategy($this->strategyData->setStrategyData([], 'YourResource deleted successfully', Response::HTTP_OK));\r\n+    }\r\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725260469900,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -186,8 +186,13 @@\n         $strategy = $this->strategyData->setStrategyData(YourResource::collection($data));\r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n \r\n+public function create(): View\r\n+    {\r\n+        return View('gateway.create');\r\n+    }\r\n+    \r\n     public function store(YourRequest $request): JsonResponse|RedirectResponse\r\n     {\r\n         \r\n         $data = $this->repository->create($request->validated());\r\n"
                },
                {
                    "date": 1725260478471,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -186,13 +186,13 @@\n         $strategy = $this->strategyData->setStrategyData(YourResource::collection($data));\r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n \r\n-public function create(): View\r\n+    public function create(): View\r\n     {\r\n-        return View('gateway.create');\r\n+        return View('YourResource.create');\r\n     }\r\n-    \r\n+\r\n     public function store(YourRequest $request): JsonResponse|RedirectResponse\r\n     {\r\n         \r\n         $data = $this->repository->create($request->validated());\r\n"
                },
                {
                    "date": 1725260484137,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -186,9 +186,9 @@\n         $strategy = $this->strategyData->setStrategyData(YourResource::collection($data));\r\n         return $this->responseContext->executeStrategy($strategy);\r\n     }\r\n \r\n-\r\n+/\r\n     public function create(): View\r\n     {\r\n         return View('yourResource.create');\r\n     }\r\n"
                },
                {
                    "date": 1725260574062,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,236 @@\n+# anasa-response-strategy\r\n+Package to isolate the logic that determines the return type of the controller based on the source (API/Web)\r\n+\r\n+This is an optional solution in Laravel to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n+\r\n+## How it works\r\n+1- From a middleware or similar logic set the Additional Data Request and identify the required Response Strategy\r\n+\r\n+```php\r\n+<?php\r\n+\r\n+namespace App\\Http\\Middleware;\r\n+\r\n+use Closure;\r\n+use Illuminate\\Http\\Request;\r\n+use SebastianBergmann\\Type\\Exception;\r\n+use Symfony\\Component\\HttpFoundation\\Response;\r\n+use Anasa\\ResponseStrategy\\ResponseStrategyFactory;\r\n+use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n+use Anasa\\ResponseStrategy\\Facades\\AdditionalDataRequest;\r\n+\r\n+class ApiOrWebMiddleware\r\n+{\r\n+    public function __construct(protected ResponseContextInterface $responseContext)\r\n+    {\r\n+    }\r\n+\r\n+    /**\r\n+     * Handle an incoming request.\r\n+     *\r\n+     * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response)  $next\r\n+     */\r\n+    public function handle(Request $request, Closure $next): Response\r\n+    {\r\n+        /**\r\n+         * Set additional data request:\r\n+         * this will add the controller, method, view and resource. It's\r\n+         * some dinamic data to be used in the strategy to identify and build\r\n+         * the response. A facade will be used.\r\n+         */\r\n+        $this->setAdditionalDataRequest($request);\r\n+\r\n+        $this->defineResponseStrategy();\r\n+\r\n+        return $next($request);\r\n+    }\r\n+\r\n+    private function setAdditionalDataRequest(Request $request): void\r\n+    {\r\n+        $action = $request->route()->getAction();\r\n+        $controller = class_basename($action['controller']);\r\n+        [, $methodName] = explode('@', $controller);\r\n+\r\n+        /**\r\n+         * facades, the intentions is to have a dinamic data abaliable for all app\r\n+         *  without need to create dependencies\r\n+         **/\r\n+\r\n+        AdditionalDataRequest::setMethod($request->expectsJson() || $request->is('api/*') ? 'API' : $methodName);\r\n+        AdditionalDataRequest::setView($request->route()->getName());\r\n+        AdditionalDataRequest::setRoute($request->route()->getName());\r\n+    }\r\n+\r\n+    /**\r\n+     * Used factory design patterns to create the response strategy.\r\n+     */\r\n+    public function defineResponseStrategy()\r\n+    {\r\n+        try {\r\n+            //Factory Method, returns a concrete instance based on the ResponseStrategy interface.\r\n+            $strategy = ResponseStrategyFactory::createStrategy(AdditionalDataRequest::getMethod());\r\n+        } catch (Exception $e) {\r\n+            throw new Exception('Unknown method');\r\n+        }\r\n+\r\n+        $this->responseContext->setStrategy($strategy);\r\n+    }\r\n+}\r\n+\r\n+```\r\n+**Notes:**\r\n+- setMethod will set as API for all input\r\n+- If your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n+```php\r\n+AdditionalDataRequest::setMethod($request->expectsJson() || $request->is('api/*') ? 'API' : $methodName);\r\n+```\r\n+\r\n+2- Set Service Provider and Response Service provider,\r\n+\r\n+```php\r\n+<?php\r\n+\r\n+namespace App\\Providers;\r\n+\r\n+use Illuminate\\Support\\ServiceProvider;\r\n+use Anasa\\ResponseStrategy\\AdditionalDataRequest;\r\n+\r\n+class AppServiceProvider extends ServiceProvider\r\n+{\r\n+    /**\r\n+     * Register any application services.\r\n+     */\r\n+    public function register(): void\r\n+    {\r\n+        //...\r\n+        $this->app->singleton('additionalDataRequest', function ($app) {\r\n+            return new AdditionalDataRequest;\r\n+        });\r\n+    }\r\n+\r\n+    /**\r\n+     * Bootstrap any application services.\r\n+     */\r\n+    public function boot(): void\r\n+    {\r\n+       //\r\n+    }\r\n+}\r\n+\r\n+```\r\n+\r\n+```php\r\n+<?php\r\n+\r\n+namespace App\\Providers;\r\n+\r\n+use Illuminate\\Support\\ServiceProvider;\r\n+use Anasa\\ResponseStrategy\\ResponseContext;\r\n+use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n+use Anasa\\ResponseStrategy\\Output\\ApiResponseStrategy;\r\n+use Anasa\\ResponseStrategy\\Output\\ViewResponseStrategy;\r\n+use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyData;\r\n+use Anasa\\ResponseStrategy\\Output\\RedirectResponseStrategy;\r\n+use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyDataInterface;\r\n+\r\n+class ResponseServiceProvider extends ServiceProvider\r\n+{\r\n+    public function register()\r\n+    {\r\n+        $this->app->bind(ApiResponseStrategy::class, function ($app) {\r\n+            return new ApiResponseStrategy();\r\n+        });\r\n+\r\n+        $this->app->bind(ViewResponseStrategy::class, function ($app) {\r\n+            return new ViewResponseStrategy();\r\n+        });\r\n+\r\n+        $this->app->bind(RedirectResponseStrategy::class, function ($app) {\r\n+            return new RedirectResponseStrategy();\r\n+        });\r\n+        $this->app->bind(StrategyDataInterface::class, function ($app) {\r\n+            return new StrategyData();\r\n+        });\r\n+\r\n+        $this->app->singleton(ResponseContextInterface::class, function ($app) {\r\n+            return new ResponseContext();\r\n+        });\r\n+    }\r\n+}\r\n+\r\n+```\r\n+\r\n+3- Using it in your controller\r\n+\r\n+```php\r\n+<?php\r\n+\r\n+namespace App\\Http\\Controllers;\r\n+\r\n+use Illuminate\\Http\\JsonResponse;\r\n+use Illuminate\\Contracts\\View\\View;\r\n+use App\\Http\\Controllers\\Controller;\r\n+use App\\Repositories\\CrudRepositoryInterface;\r\n+use Anasa\\ResponseStrategy\\ResponseContextInterface;\r\n+use Anasa\\ResponseStrategy\\OutputDataFormat\\StrategyDataInterface;\r\n+\r\n+class YourController extends Controller\r\n+{\r\n+    public function __construct(protected CrudRepositoryInterface $repository, protected ResponseContextInterface $responseContext, protected StrategyDataInterface $strategyData)\r\n+    {\r\n+    }\r\n+    \r\n+    public function index(): View|JsonResponse\r\n+    {\r\n+        $data = $this->repository->all();\r\n+        $strategy = $this->strategyData->setStrategyData(YourResource::collection($data));\r\n+        return $this->responseContext->executeStrategy($strategy);\r\n+    }\r\n+\r\n+    /**\r\n+     * No strategy needed\r\n+    */\r\n+    public function create(): View\r\n+    {\r\n+        return View('yourResource.create');\r\n+    }\r\n+\r\n+    public function store(YourRequest $request): JsonResponse|RedirectResponse\r\n+    {\r\n+        \r\n+        $data = $this->repository->create($request->validated());\r\n+\r\n+        $strategy = $this->strategyData->setStrategyData(new YourResource($data), 'YourResource created successfully', Response::HTTP_CREATED);\r\n+\r\n+        return $this->responseContext->executeStrategy($strategy);\r\n+    }\r\n+\r\n+    public function show($id): JsonResponse|View\r\n+    {\r\n+        $data = $this->repository->find($id); //it uses findOrFail from the repository\r\n+        $strategy = $this->strategyData->setStrategyData(new YourResource($data));\r\n+\r\n+        return $this->responseContext->executeStrategy($strategy);\r\n+    }\r\n+\r\n+    public function edit(string $id): View\r\n+    {\r\n+        $data = $this->repository->find($id); //it uses findOrFail\r\n+        return View('gateway.edit', ['YourData' => $data]);\r\n+    }\r\n+\r\n+    public function update(YourRequest $request, string $id): JsonResponse|RedirectResponse\r\n+    {\r\n+        $updated_data = $this->repository->update($id, $request->validated()); //it uses findOrFail\r\n+        $strategy = $this->strategyData->setStrategyData(new YourResource($updated_data), 'YourResource updated successfully', Response::HTTP_OK);\r\n+\r\n+        return $this->responseContext->executeStrategy($strategy);\r\n+    }\r\n+\r\n+    public function destroy($id): JsonResponse|RedirectResponse\r\n+    {\r\n+        $this->repository->delete($id); //it uses findOrFail\r\n+\r\n+        return $this->responseContext->executeStrategy($this->strategyData->setStrategyData([], 'YourResource deleted successfully', Response::HTTP_OK));\r\n+    }\r\n+```\n\\ No newline at end of file\n"
                }
            ],
            "date": 1725258548512,
            "name": "Commit-0",
            "content": "# anasa-response-strategy\r\nPackage to isolate the logic that determines the return type of the controller based on the source (API/Web)\r\n\r\nThis is an optional solution to handle the type of output that will be implemented for a crud. Make sure to respect the naming standards or you will need to modify the AdditionalDataRequest inputs for (setMethod, setView, setRoute).\r\n\r\nNote:\r\nsetMethod will set as API for all input\r\nIf your project uses a custom prefix for API inputs, make sure to add the Accept: application/json Header for later identification of a json output.\r\n"
        }
    ]
}